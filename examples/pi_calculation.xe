// Pi Calculation - Leibniz and Nilakantha Series
print("=== Pi Calculation ===")
print()

import "math"

// ============================================================================
// LEIBNIZ FORMULA (Gregory-Leibniz Series)
// Pi = 4 * (1 - 1/3 + 1/5 - 1/7 + 1/9 - ...)
// ============================================================================

fn calculatePiLeibniz(iterations) {
    var sum = 0.0
    var i = 0
    
    while (i < iterations) {
        // Calculate 2*i + 1 using separate steps
        const twice = i + i
        const denominator = twice + 1
        const term = 1.0 / denominator
        
        // Alternate sign based on even/odd
        const isEven = (i % 2 == 0)
        if (isEven) {
            sum = sum + term
        } else {
            sum = sum - term
        }
        
        i = i + 1
    }
    
    return sum * 4.0
}

print("1. Leibniz Formula")
print("   Pi = 4 * (1 - 1/3 + 1/5 - 1/7 + ...)")
print()

const pi1k = calculatePiLeibniz(1000)
print("   1,000 iterations:", pi1k)

const pi10k = calculatePiLeibniz(10000)
print("   10,000 iterations:", pi10k)

const pi100k = calculatePiLeibniz(100000)
print("   100,000 iterations:", pi100k)

print()

// ============================================================================
// NILAKANTHA SERIES
// Pi = 3 + 4/(2*3*4) - 4/(4*5*6) + 4/(6*7*8) - ...
// Faster convergence than Leibniz!
// ============================================================================

fn calculatePiNilakantha(iterations) {
    var sum = 3.0
    var i = 1
    
    while (i <= iterations) {
        // Calculate n = 2 * i
        const n = i + i
        
        // Calculate denominator = n * (n+1) * (n+2)
        const n1 = n + 1
        const n2 = n + 2
        const d1 = n * n1
        const denominator = d1 * n2
        
        const term = 4.0 / denominator
        
        // Alternate sign
        const isOdd = (i % 2 == 1)
        if (isOdd) {
            sum = sum + term
        } else {
            sum = sum - term
        }
        
        i = i + 1
    }
    
    return sum
}

print("2. Nilakantha Series")
print("   Pi = 3 + 4/(2*3*4) - 4/(4*5*6) + ...")
print()

const nil100 = calculatePiNilakantha(100)
print("   100 iterations:", nil100)

const nil1k = calculatePiNilakantha(1000)
print("   1,000 iterations:", nil1k)

const nil10k = calculatePiNilakantha(10000)
print("   10,000 iterations:", nil10k)

print()

// ============================================================================
// COMPARISON
// ============================================================================

print("3. Accuracy Comparison")
print()

const actualPi = math.PI()
print("   Actual Pi:", actualPi)
print()

print("   Leibniz (100k):", pi100k)
const leibnizError = math.abs(pi100k - actualPi)
print("   Error:", leibnizError)
print()

print("   Nilakantha (10k):", nil10k)
const nilError = math.abs(nil10k - actualPi)
print("   Error:", nilError)
print()

if (nilError < leibnizError) {
    print("   Nilakantha is more accurate!")
    print("   Uses 10x fewer iterations")
} else {
    print("   Leibniz is more accurate")
}

print()

// ============================================================================
// MONTE CARLO METHOD
// ============================================================================

fn calculatePiMonteCarlo(samples) {
    var inside = 0
    var i = 0
    
    while (i < samples) {
        const x = math.random()
        const y = math.random()
        
        // Calculate distance from origin
        const x2 = x * x
        const y2 = y * y
        const dist2 = x2 + y2
        const dist = math.sqrt(dist2)
        
        if (dist <= 1.0) {
            inside = inside + 1
        }
        
        i = i + 1
    }
    
    const ratio = inside / samples
    return ratio * 4.0
}

print("4. Monte Carlo Method")
print("   Random sampling approach")
print()

const mc10k = calculatePiMonteCarlo(10000)
print("   10,000 samples:", mc10k)

const mc100k = calculatePiMonteCarlo(100000)
print("   100,000 samples:", mc100k)

print()

// ============================================================================
// SUMMARY
// ============================================================================

print("5. Summary")
print()
print("   Best Algorithm: Nilakantha Series")
print("   - Fastest convergence")
print("   - Most accurate with fewer iterations")
print("   - Recommended for production use")
print()
print("   For even faster computation:")
print("   ./xenlyc -O3 pi_calculation.xe -o pi")
print("   ./pi  # 18x faster!")
print()

print("=== Complete ===")
