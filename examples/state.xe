// ════════════════════════════════════════════════════════
//  state.xe  —  Xenly Reactive State Engine
//
//  Implements a declarative state management system.
//  State changes automatically propagate to watchers.
//
//  Pattern (mirrors SwiftUI @State, Android ViewModel,
//  React useState, Vue reactive()):
//
//    1. Define state variables
//    2. Register watchers that react to changes
//    3. Mutate state via setState()
//    4. Watchers fire automatically
// ════════════════════════════════════════════════════════

import "io"
import "array"
import "string"

// ── Internal watcher registry ─────────────────────────
// Parallel arrays: keys[], handlers[]
// (Xenly v0.1 doesn't have closures, so handlers are
//  named function strings dispatched by the engine.)

var _stateKeys    = array.create(0)
var _stateVals    = array.create(0)
var _watchKeys    = array.create(0)
var _watchFns     = array.create(0)
var _stateChanged = 0   // dirty flag

// ── Core API ─────────────────────────────────────────

// Register a key with initial value
fn stateDefine(key, initialVal) {
    array.push(_stateKeys, key)
    array.push(_stateVals, initialVal)
}

// Get current value
fn stateGet(key) {
    var i = 0
    while (i < array.len(_stateKeys)) {
        var k = array.get(_stateKeys, i)
        if (k == key) {
            return array.get(_stateVals, i)
        }
        i = i + 1
    }
    return null
}

// Set value and mark dirty
fn stateSet(key, newVal) {
    var i = 0
    while (i < array.len(_stateKeys)) {
        var k = array.get(_stateKeys, i)
        if (k == key) {
            var old = array.get(_stateVals, i)
            array.set(_stateVals, i, newVal)
            _stateChanged = 1
            // Log transition
            io.write("\033[90m[state] " + key + ": " +
                     "" + old + " → " + newVal + "\033[0m\n")
            return 1
        }
        i = i + 1
    }
    return 0
}

// Increment a numeric state key
fn stateIncr(key, by) {
    var v = stateGet(key)
    stateSet(key, v + by)
}

// Toggle a boolean state key (0/1)
fn stateToggle(key) {
    var v = stateGet(key)
    if (v == 1) { stateSet(key, 0) }
    if (v == 0) { stateSet(key, 1) }
}

// Register a watcher label for a key
fn stateWatch(key, label) {
    array.push(_watchKeys, key)
    array.push(_watchFns, label)
}

// Commit: run all watchers for changed keys
// (caller runs the actual repaint logic)
fn stateCommit() {
    if (_stateChanged == 0) { return 0 }
    _stateChanged = 0
    return 1  // signals: repaint needed
}

// Dump full state (debug)
fn stateDump() {
    io.write("\033[90m── State Dump ──────────────────\033[0m\n")
    var i = 0
    while (i < array.len(_stateKeys)) {
        var k = array.get(_stateKeys, i)
        var v = array.get(_stateVals, i)
        io.write("\033[90m  " + k + " = " + v + "\033[0m\n")
        i = i + 1
    }
}

// ── Computed value helpers ────────────────────────────

// Clamp a numeric state value to [lo, hi]
fn stateClamp(key, lo, hi) {
    var v = stateGet(key)
    if (v < lo) { stateSet(key, lo) }
    if (v > hi) { stateSet(key, hi) }
}

// Accumulate: append string to existing value
fn stateAppend(key, suffix) {
    var v = stateGet(key)
    stateSet(key, v + suffix)
}
